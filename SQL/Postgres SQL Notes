
------------------
SELECT
------------------

SELECT
   first_name,
   last_name,
   email
FROM
   customer;

SELECT
   first_name || ' ' || last_name,
   email
FROM
   customer;


------------------
COLUMN ALIAS
------------------

SELECT
   first_name,
   last_name AS surname
FROM customer;


------------------
ORDER BY
------------------

SELECT
first_name,
last_name
FROM
customer
ORDER BY
first_name ASC;

SELECT
first_name,
last_name
FROM
customer
ORDER BY
first_name ASC,
last_name DESC;

SELECT
first_name,
LENGTH(first_name) len
FROM
customer
ORDER BY
len DESC;

SELECT num
FROM sort_demo
ORDER BY num NULLS FIRST;

SELECT num
FROM sort_demo
ORDER BY num DESC NULLS LAST;

------------------
DISTINCT
------------------

SELECT
DISTINCT bcolor
FROM
distinct_demo
ORDER BY
bcolor;

SELECT
DISTINCT bcolor,
fcolor
FROM
distinct_demo
ORDER BY
bcolor,
fcolor;

SELECT
DISTINCT ON (bcolor) bcolor,
fcolor
FROM
distinct_demo
ORDER BY
bcolor,
fcolor;


------------------
WHERE
------------------

SELECT
first_name,
last_name
FROM
customer
WHERE
last_name = 'Rodriguez' OR
first_name = 'Adam';

SELECT
first_name,
last_name
FROM
customer
WHERE
first_name IN ('Ann','Anne','Annie');

SELECT
first_name,
LENGTH(first_name) name_length
FROM
customer
WHERE
first_name LIKE 'A%' AND
LENGTH(first_name) BETWEEN 3 AND 5
ORDER BY
name_length;

SELECT
first_name,
last_name
FROM
customer
WHERE
first_name LIKE 'Bra%' AND
last_name <> 'Motley';


------------------
LIMIT
------------------

SELECT
film_id,
title,
release_year
FROM
film
ORDER BY
film_id
LIMIT 4 OFFSET 3;

SELECT
film_id,
title,
rental_rate
FROM
film
ORDER BY
rental_rate DESC
LIMIT 10;


------------------
FETCH
------------------

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title
FETCH FIRST ROW ONLY;

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title
FETCH FIRST 1 ROW ONLY;

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title
FETCH FIRST 5 ROW ONLY;

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title
OFFSET 5 ROWS
FETCH FIRST 5 ROW ONLY;


------------------
IN
------------------

SELECT
customer_id,
first_name,
last_name
FROM
customer
WHERE
customer_id IN (
SELECT customer_id
FROM rental
WHERE CAST (return_date AS DATE) = '2005-05-27'
)
ORDER BY customer_id;


------------------
BETWEEN
------------------

SELECT
customer_id,
payment_id,
amount,
 payment_date
FROM
payment
WHERE
payment_date BETWEEN '2007-02-07' AND '2007-02-15';


------------------
LIKE
------------------

SELECT
first_name,
        last_name
FROM
customer
WHERE
first_name LIKE '%er%'
ORDER BY
        first_name;

SELECT
first_name,
last_name
FROM
customer
WHERE
first_name NOT LIKE 'Jen%'
ORDER BY
        first_name;

------------------
IS NULL
------------------

CREATE TABLE contacts(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(15),
    PRIMARY KEY (id)
);

INSERT INTO contacts(first_name, last_name, email, phone)
VALUES ('John','Doe','john.doe@example.com',NULL),
    ('Lily','Bush','lily.bush@example.com','(408-234-2764)');

SELECT
    id,
    first_name,
    last_name,
    email,
    phone
FROM
    contacts
WHERE
    phone IS NOT NULL;


------------------
JOINS
------------------

-- Inner join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
INNER JOIN basket_b
    ON fruit_a = fruit_b;

-- Left join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
LEFT JOIN basket_b
   ON fruit_a = fruit_b;

-- Left outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
LEFT JOIN basket_b
    ON fruit_a = fruit_b
WHERE b IS NULL;

-- Right join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
RIGHT JOIN basket_b ON fruit_a = fruit_b;

-- Right outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
RIGHT JOIN basket_b
   ON fruit_a = fruit_b
WHERE a IS NULL;

-- Full outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
FULL OUTER JOIN basket_b
    ON fruit_a = fruit_b;

-- Full outer join

SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
FULL JOIN basket_b
   ON fruit_a = fruit_b
WHERE a IS NULL OR b IS NULL;


------------------
TABLE ALIASES
------------------

SELECT
    e.first_name employee,
    m.first_name manager
FROM
    employee e
INNER JOIN employee m
    ON m.employee_id = e.manager_id
ORDER BY manager;


------------------
INNER JOIN
------------------

SELECT
c.customer_id,
c.first_name customer_first_name,
c.last_name customer_last_name,
s.first_name staff_first_name,
s.last_name staff_last_name,
amount,
payment_date
FROM
customer c
INNER JOIN payment p
    ON p.customer_id = c.customer_id
INNER JOIN staff s
    ON p.staff_id = s.staff_id
ORDER BY payment_date;

SELECT
customer_id,
first_name,
last_name,
amount,
payment_date
FROM
customer
INNER JOIN payment USING(customer_id)
ORDER BY payment_date;


------------------
LEFT JOIN
------------------

SELECT
f.film_id,
title,
inventory_id
FROM
film f
LEFT JOIN inventory i USING (film_id)
WHERE i.film_id IS NULL
ORDER BY title;


------------------
SELF JOIN
------------------

SELECT
    e.first_name || ' ' || e.last_name employee,
    m .first_name || ' ' || m .last_name manager
FROM
    employee e
INNER JOIN employee m ON m .employee_id = e.manager_id
ORDER BY manager;


SELECT
    f1.title,
    f2.title,
    f1.length
FROM
    film f1
INNER JOIN film f2
    ON f1.film_id <> f2.film_id AND
       f1.length = f2.length;


------------------
FULL OUTER JOIN
------------------

SELECT
employee_name,
department_name
FROM
employees e
FULL OUTER JOIN departments d
        ON d.department_id = e.department_id;


SELECT
employee_name,
department_name
FROM
employees e
FULL OUTER JOIN departments d ON d.department_id = e.department_id
WHERE
department_name IS NULL;


------------------
CROSS JOIN
------------------

SELECT *
FROM T1
CROSS JOIN T2;


------------------
NATURAL JOIN
------------------

-- Not need to specify the country_id
SELECT *
FROM city
NATURAL JOIN country;


------------------
GROUP BY
------------------

SELECT
DATE(payment_date) paid_date,
SUM(amount) sum
FROM
payment
GROUP BY
DATE(payment_date);


------------------
HAVING
------------------

SELECT
store_id,
COUNT (customer_id)
FROM
customer
GROUP BY
store_id
HAVING
COUNT (customer_id) > 300;


------------------
UNION
------------------

-- No duplicate rows
SELECT * FROM top_rated_films
UNION
SELECT * FROM most_popular_films;

-- Duplicate rows retained
SELECT * FROM top_rated_films
UNION ALL
SELECT * FROM most_popular_films;


------------------
INTERSECT
------------------

-- The set of rows that appear in both tables
SELECT *
FROM most_popular_films
INTERSECT
SELECT *
FROM top_rated_films;


------------------
EXCEPT
------------------

-- The top-rated films that are not popular
SELECT * FROM top_rated_films
EXCEPT
SELECT * FROM most_popular_films;


------------------
GROUPING SETS
------------------

SELECT
    brand,
    segment,
    SUM (quantity)
FROM
    sales
GROUP BY
    GROUPING SETS (
        (brand, segment),
        (brand),
        (segment),
        ()
    );

SELECT
GROUPING(brand) grouping_brand,
GROUPING(segment) grouping_segment,
brand,
segment,
SUM (quantity)
FROM
sales
GROUP BY
GROUPING SETS (
(brand),
(segment),
()
)
ORDER BY
brand,
segment;

SELECT
GROUPING(brand) grouping_brand,
GROUPING(segment) grouping_segment,
brand,
segment,
SUM (quantity)
FROM
sales
GROUP BY
GROUPING SETS (
(brand),
(segment),
()
)
HAVING GROUPING(brand) = 0
ORDER BY
brand,
segment;


------------------
CUBE
------------------

-- The CUBE subclause is a short way to define multiple grouping sets so the following are equivalent

CUBE(c1,c2,c3)

GROUPING SETS (
    (c1,c2,c3),
    (c1,c2),
    (c1,c3),
    (c2,c3),
    (c1),
    (c2),
    (c3),
    ()
 )


------------------
ROLLUP
------------------

ROLLUP(c1,c2,c3)

GROUPING SETS (
(c1, c2, c3)
(c1, c2)
(c1)
()
)


------------------
SUBQUERY
------------------

SELECT
film_id,
title,
rental_rate
FROM
film
WHERE
rental_rate > (
SELECT
AVG (rental_rate)
FROM
film
);

SELECT
film_id,
title
FROM
film
WHERE
film_id IN (
SELECT
inventory.film_id
FROM
rental
INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id
WHERE
return_date BETWEEN '2005-05-29'
AND '2005-05-30'
);

SELECT
first_name,
last_name
FROM
customer
WHERE
EXISTS (
SELECT
1
FROM
payment
WHERE
payment.customer_id = customer.customer_id
);


------------------
ANY
------------------

SELECT
    title,
    category_id
FROM
    film
INNER JOIN film_category
        USING(film_id)
WHERE
    category_id = ANY(
        SELECT
            category_id
        FROM
            category
        WHERE
            NAME = 'Action'
            OR NAME = 'Drama'
    );

SELECT
    title,
    category_id
FROM
    film
INNER JOIN film_category
        USING(film_id)
WHERE
    category_id IN(
        SELECT
            category_id
        FROM
            category
        WHERE
            NAME = 'Action'
            OR NAME = 'Drama'
    );


------------------
ALL
------------------

SELECT
    film_id,
    title,
    length
FROM
    film
WHERE
    length > ALL (
            SELECT
                ROUND(AVG (length),2)
            FROM
                film
            GROUP BY
                rating
    )
ORDER BY
    length;


------------------
EXISTS
------------------

SELECT first_name,
       last_name
FROM customer c
WHERE EXISTS
    (SELECT 1
     FROM payment p
     WHERE p.customer_id = c.customer_id
       AND amount > 11 )
ORDER BY first_name,
         last_name;

SELECT first_name,
       last_name
FROM customer c
WHERE NOT EXISTS
    (SELECT 1
     FROM payment p
     WHERE p.customer_id = c.customer_id
       AND amount > 11 )
ORDER BY first_name,
         last_name;

-- If the subquery returns NULL, EXISTS returns true
SELECT
first_name,
last_name
FROM
customer
WHERE
EXISTS( SELECT NULL )
ORDER BY
first_name,
last_name;


------------------
INSERT
------------------

INSERT INTO links (url, name)
VALUES('http://www.postgresql.org','PostgreSQL')
RETURNING id;

INSERT INTO links (url, name, last_update)
VALUES('https://www.google.com','Google','2013-06-01');


------------------
INSERT MULTIPLE ROWS
------------------

DROP TABLE IF EXISTS links;

CREATE TABLE links (
    id SERIAL PRIMARY KEY,
    url VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description VARCHAR(255)
);

INSERT INTO
    links (url, name)
VALUES
    ('https://www.google.com','Google'),
    ('https://www.yahoo.com','Yahoo'),
    ('https://www.bing.com','Bing');


------------------
UPDATE
------------------

UPDATE courses
SET published_date = '2020-08-01'
WHERE course_id = 3;

-- updating a row and returning the updated row
UPDATE courses
SET published_date = '2020-07-01'
WHERE course_id = 2
RETURNING *;


------------------
UPDATE JOIN
------------------

UPDATE product
SET net_price = price - price * discount
FROM product_segment
WHERE product.segment_id = product_segment.id;


------------------
DELETE
------------------

DELETE FROM links
WHERE id IN (6,5)
RETURNING *;


------------------
UPSERT
------------------

INSERT INTO customers (name, email)
VALUES('Microsoft','hotline@microsoft.com')
ON CONFLICT (name)
DO
   UPDATE SET email = EXCLUDED.email || ';' || customers.email;


------------------
TRANSACTIONS
------------------

-- start a transaction
BEGIN;

-- deduct 1000 from account 1
UPDATE accounts
SET balance = balance - 1000
WHERE id = 1;

-- add 1000 to account 2
UPDATE accounts
SET balance = balance + 1000
WHERE id = 2;

-- select the data from accounts
SELECT id, name, balance
FROM accounts;

-- commit the transaction
COMMIT;


-- begin the transaction
BEGIN;

-- deduct the amount from the account 1
UPDATE accounts
SET balance = balance - 1500
WHERE id = 1;

-- add the amount from the account 3 (instead of 2)
UPDATE accounts
SET balance = balance + 1500
WHERE id = 3;

-- roll back the transaction
ROLLBACK;


------------------
DATA TYPE
------------------

Boolean
Character types such as char, varchar, and text.
Numeric types such as integer and floating-point number.
Temporal types such as date, time, timestamp, and interval
UUID for storing Universally Unique Identifiers
Array for storing array strings, numbers, etc.
JSON stores JSON data
hstore stores key-value pair
Special types such as network address and geometric data.


------------------
CREATE TABLE
------------------

CREATE TABLE account_roles (
  user_id INT NOT NULL,
  role_id INT NOT NULL,
  grant_date TIMESTAMP,
  PRIMARY KEY (user_id, role_id),
  FOREIGN KEY (role_id)
      REFERENCES roles (role_id),
  FOREIGN KEY (user_id)
      REFERENCES accounts (user_id)
);


------------------
SELECT INTO
------------------

SELECT
    film_id,
    title,
    length
INTO TEMP TABLE short_film
FROM
    film
WHERE
    length < 60
ORDER BY
    title;


------------------
CREATE TABLE AS
------------------

CREATE TABLE IF NOT EXISTS film_rating (rating, film_count)
AS
SELECT
    rating,
    COUNT (film_id)
FROM
    film
GROUP BY
    rating;


------------------
SERIAL
------------------

CREATE SEQUENCE table_name_id_seq;

CREATE TABLE table_name (
    id integer NOT NULL DEFAULT nextval('table_name_id_seq')
);

ALTER SEQUENCE table_name_id_seq
OWNED BY table_name.id;


------------------
SEQUENCE
------------------

CREATE SEQUENCE order_item_id
START 10
INCREMENT 10
MINVALUE 10
OWNED BY order_details.item_id;

INSERT INTO
    order_details(order_id, item_id, item_text, price)
VALUES
    (100, nextval('order_item_id'),'DVD Player',100),
    (100, nextval('order_item_id'),'Android TV',550),
    (100, nextval('order_item_id'),'Speaker',250);


------------------
IDENTITY COLUMN
------------------

ALTER TABLE shape
ALTER COLUMN shape_id ADD GENERATED ALWAYS AS IDENTITY;

ALTER TABLE shape
ALTER COLUMN shape_id
DROP IDENTITY IF EXISTS;


------------------
ALTER TABLE
------------------

ALTER TABLE links
ADD CHECK (target IN ('_self', '_blank', '_parent', '_top'));

ALTER TABLE links
ADD CONSTRAINT unique_url UNIQUE ( url );

INSERT INTO links(link_title,url)
VALUES('PostgreSQL','https://www.postgresqltutorial.com/');


------------------
RENAME TABLE
------------------

CREATE VIEW supplier_data
AS SELECT
    s.id,
    s.name,
    g.name  supply_group
FROM
    suppliers s
INNER JOIN supplier_groups g ON g.id = s.group_id;

ALTER TABLE table_name
RENAME TO new_table_name;


------------------
ADD COLUMN
------------------

ALTER TABLE customers
ADD COLUMN contact_name VARCHAR;

ALTER TABLE customers
ALTER COLUMN contact_name SET NOT NULL;


------------------
DROP COLUMN
------------------

ALTER TABLE books
  DROP COLUMN isbn,
  DROP COLUMN description;


------------------
CHANGE COLUMN TYPE
------------------

CREATE TABLE assets (
    id serial PRIMARY KEY,
    name TEXT NOT NULL,
    asset_no VARCHAR NOT NULL,
    description TEXT,
    location TEXT,
    acquired_date DATE NOT NULL
);

INSERT INTO assets(name,asset_no,location,acquired_date)
VALUES('Server','10001','Server room','2017-01-01'),
      ('UPS','10002','Server room','2017-01-01');

ALTER TABLE assets
ALTER COLUMN asset_no TYPE INT
USING asset_no::integer;

ALTER TABLE assets
    ALTER COLUMN location TYPE VARCHAR,
    ALTER COLUMN description TYPE VARCHAR;


------------------
RENAME COLUMN
------------------

ALTER TABLE customers
RENAME COLUMN phone TO contact_phone;


------------------
DROP TABLE
------------------

DROP TABLE tvshows, animes;


------------------
TRUNCATE TABLE
------------------

-- Use the CASCADE option to truncate a table and other tables that reference the table via foreign key constraint.
TRUNCATE TABLE invoices, customers;


------------------
TEMPORARY TABLE
------------------

CREATE TEMPORARY TABLE temp_table_name(
   column_list
);


------------------
COPY TABLE
------------------

CREATE TABLE contact_backup
AS TABLE contacts;

ALTER TABLE contact_backup ADD PRIMARY KEY(id);
ALTER TABLE contact_backup ADD UNIQUE(email);